<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · CoordinateTransformations.jl</title><meta name="title" content="Introduction · CoordinateTransformations.jl"/><meta property="og:title" content="Introduction · CoordinateTransformations.jl"/><meta property="twitter:title" content="Introduction · CoordinateTransformations.jl"/><meta name="description" content="Documentation for CoordinateTransformations.jl."/><meta property="og:description" content="Documentation for CoordinateTransformations.jl."/><meta property="twitter:description" content="Documentation for CoordinateTransformations.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CoordinateTransformations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Quick-start"><span>Quick start</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Built-in-transformations"><span>Built-in transformations</span></a></li><li><a class="tocitem" href="#Acknowledgements"><span>Acknowledgements</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/CoordinateTransformations.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaGeometry/CoordinateTransformations.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CoordinateTransformations"><a class="docs-heading-anchor" href="#CoordinateTransformations">CoordinateTransformations</a><a id="CoordinateTransformations-1"></a><a class="docs-heading-anchor-permalink" href="#CoordinateTransformations" title="Permalink"></a></h1><p><a href="https://github.com/JuliaGeometry/CoordinateTransformations.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaGeometry/CoordinateTransformations.jl/workflows/CI/badge.svg" alt="Build Status"/></a></p><p><strong>CoordinateTransformations</strong> is a Julia package to manage simple or complex networks of coordinate system transformations. Transformations can be easily applied, inverted, composed, and differentiated (both with respect to the input coordinates and with respect to transformation parameters such as rotation angle). Transformations are designed to be light-weight and efficient enough for, e.g., real-time graphical applications, while support for both explicit and automatic differentiation makes it easy to perform optimization and therefore ideal for computer vision applications such as SLAM (simultaneous localization and mapping).</p><p>The package provide two main pieces of functionality</p><ol><li><p>Primarily, an interface for defining <code>Transformation</code>s and applying (by calling), inverting (<code>inv()</code>), composing (<code>∘</code> or <code>compose()</code>) and differentiating (<code>transform_deriv()</code> and <code>transform_deriv_params()</code>) them.</p></li><li><p>A small set of built-in, composable, primitive transformations for transforming 2D and 3D points (optionally leveraging the <em>StaticArrays</em> and <em>Rotations</em> packages).</p></li></ol><h2 id="Quick-start"><a class="docs-heading-anchor" href="#Quick-start">Quick start</a><a id="Quick-start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-start" title="Permalink"></a></h2><p>Let&#39;s translate a 3D point:</p><pre><code class="language-julia hljs">using CoordinateTransformations, Rotations, StaticArrays

x = SVector(1.0, 2.0, 3.0)  # SVector is provided by StaticArrays.jl
trans = Translation(3.5, 1.5, 0.0)

y = trans(x)</code></pre><p>We can either apply different transformations in turn,</p><pre><code class="language-julia hljs">rot = LinearMap(RotX(0.3))  # Rotate 0.3 radians about X-axis, from Rotations.jl

z = trans(rot(x))</code></pre><p>or build a composed transformation using the <code>∘</code> operator (accessible at the REPL by typing <code>\circ</code> then tab):</p><pre><code class="language-julia hljs">composed = trans ∘ rot  # alternatively, use compose(trans, rot)

composed(x) == z</code></pre><p>A composition of a <code>Translation</code> and a <code>LinearMap</code> results in an <code>AffineMap</code>.</p><p>We can invert the transformation:</p><pre><code class="language-julia hljs">composed_inv = inv(composed)

composed_inv(z) == x</code></pre><p>For any transformation, we can shift the origin to a new point using <code>recenter</code>:</p><pre><code class="language-julia hljs">rot_around_x = recenter(rot, x)</code></pre><p>Now <code>rot_around_x</code> is a rotation around the point <code>x = SVector(1.0, 2.0, 3.0)</code>.</p><p>Finally, we can construct a matrix describing how the components of <code>z</code> differentiates with respect to components of <code>x</code>:</p><pre><code class="language-julia hljs"># In general, the transform may be non-linear, and thus we require
# the value of x to compute the derivative
∂z_∂x = transform_deriv(composed, x)</code></pre><p>Or perhaps we want to know how <code>y</code> will change with respect to changes of to the translation parameters:</p><pre><code class="language-julia hljs">∂y_∂θ = transform_deriv_params(trans, x)</code></pre><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>Transformations are derived from <code>Transformation</code>. As an example, we have <code>Translation{T} &lt;: Transformation</code>. A <code>Translation</code> will accept and translate points in a variety of formats, such as <code>Vector</code> or <code>SVector</code>, but in general your custom-defined <code>Transformation</code>s could transform any Julia object.</p><p>Transformations can be reversed using <code>inv(trans)</code>. They can be chained together using the <code>∘</code> operator (<code>trans1 ∘ trans2</code>) or <code>compose</code> function (<code>compose(trans1, trans2)</code>). In this case, <code>trans2</code> is applied first to the data, before <code>trans1</code>. Composition may be intelligent, for instance by precomputing a new <code>Translation</code> by summing the elements of two existing <code>Translation</code>s, and yet other transformations may compose to the <code>IdentityTransformation</code>. But by default, composition will result in a <code>ComposedTransformation</code> object which simply dispatches to apply the transformations in the correct order.</p><p>Finally, the matrix describing how differentials propagate through a transform can be calculated with the <code>transform_deriv(trans, x)</code> method. The derivatives of how the output depends on the transformation parameters is accessed via <code>transform_deriv_params(trans, x)</code>. Users currently have to overload these methods, as no fall-back automatic differentiation is currently included. Alternatively, all the built-in types and transformations are compatible with automatic differentiation techniques, and can be parameterized by <em>DualNumbers</em>&#39; <code>DualNumber</code> or <em>ForwardDiff</em>&#39;s <code>Dual</code>.</p><h2 id="Built-in-transformations"><a class="docs-heading-anchor" href="#Built-in-transformations">Built-in transformations</a><a id="Built-in-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-transformations" title="Permalink"></a></h2><p>A small number of 2D and 3D coordinate systems and transformations are included. We also have <code>IdentityTransformation</code> and <code>ComposedTransformation</code>, which allows us to nest together arbitrary transformations to create a complex yet efficient transformation chain.</p><h3 id="Coordinate-types"><a class="docs-heading-anchor" href="#Coordinate-types">Coordinate types</a><a id="Coordinate-types-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-types" title="Permalink"></a></h3><p>The package accepts any <code>AbstractVector</code> type for Cartesian coordinates. For speed, we recommend using a statically-sized container such as <code>SVector{N}</code> from <em>StaticArrays</em>.</p><p>We do provide a few specialist coordinate types. The <code>Polar(r, θ)</code> type is a 2D polar representation of a point, and similarly in 3D we have defined <code>Spherical(r, θ, ϕ)</code> and <code>Cylindrical(r, θ, z)</code>.</p><h3 id="Coordinate-system-transformations"><a class="docs-heading-anchor" href="#Coordinate-system-transformations">Coordinate system transformations</a><a id="Coordinate-system-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Coordinate-system-transformations" title="Permalink"></a></h3><p>Two-dimensional coordinates may be converted using these parameterless (singleton) transformations:</p><ol><li><a href="api/#CoordinateTransformations.PolarFromCartesian"><code>PolarFromCartesian()</code></a></li><li><a href="api/#CoordinateTransformations.CartesianFromPolar"><code>CartesianFromPolar()</code></a></li></ol><p>Three-dimensional coordinates may be converted using these parameterless transformations:</p><ol><li><a href="api/#CoordinateTransformations.SphericalFromCartesian"><code>SphericalFromCartesian()</code></a></li><li><a href="api/#CoordinateTransformations.CartesianFromSpherical"><code>CartesianFromSpherical()</code></a></li><li><a href="api/#CoordinateTransformations.SphericalFromCylindrical"><code>SphericalFromCylindrical()</code></a></li><li><a href="api/#CoordinateTransformations.CylindricalFromSpherical"><code>CylindricalFromSpherical()</code></a></li><li><a href="api/#CoordinateTransformations.CartesianFromCylindrical"><code>CartesianFromCylindrical()</code></a></li><li><a href="api/#CoordinateTransformations.CylindricalFromCartesian"><code>CylindricalFromCartesian()</code></a></li></ol><p>However, you may find it simpler to use the convenience constructors like <code>Polar(SVector(1.0, 2.0))</code>.</p><h3 id="Translations"><a class="docs-heading-anchor" href="#Translations">Translations</a><a id="Translations-1"></a><a class="docs-heading-anchor-permalink" href="#Translations" title="Permalink"></a></h3><p>Translations can be be applied to Cartesian coordinates in arbitrary dimensions, by e.g. <code>Translation(Δx, Δy)</code> or <code>Translation(Δx, Δy, Δz)</code> in 2D/3D, or by <code>Translation(Δv)</code> in general (with <code>Δv</code> an <code>AbstractVector</code>). Compositions of two <code>Translation</code>s will intelligently create a new <code>Translation</code> by adding the translation vectors.</p><h3 id="Linear-transformations"><a class="docs-heading-anchor" href="#Linear-transformations">Linear transformations</a><a id="Linear-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-transformations" title="Permalink"></a></h3><p>Linear transformations (a.k.a. linear maps), including rotations, can be encapsulated in the <code>LinearMap</code> type, which is a simple wrapper of an <code>AbstractMatrix</code>.</p><p>You are able to provide any matrix of your choosing, but your choice of type will have a large effect on speed. For instance, if you know the dimensionality of your points (e.g. 2D or 3D) you might consider a statically sized matrix like <code>SMatrix</code> from <em>StaticArrays.jl</em>. We recommend performing 3D rotations using those from <em>Rotations.jl</em> for their speed and flexibility. Scaling will be efficient with Julia&#39;s built-in <code>UniformScaling</code>. Also note that compositions of two <code>LinearMap</code>s will intelligently create a new <code>LinearMap</code> by multiplying the transformation matrices.</p><h3 id="Affine-maps"><a class="docs-heading-anchor" href="#Affine-maps">Affine maps</a><a id="Affine-maps-1"></a><a class="docs-heading-anchor-permalink" href="#Affine-maps" title="Permalink"></a></h3><p>An Affine map encapsulates a more general set of transformation which are defined by a composition of a translation and a linear transformation. An <code>AffineMap</code> is constructed from an <code>AbstractVector</code> translation <code>v</code> and an <code>AbstractMatrix</code> linear transformation <code>M</code>. It will perform the mapping <code>x -&gt; M*x + v</code>, but the order of addition and multiplication will be more obvious (and controllable) if you construct it from a composition of a linear map and a translation, e.g. <code>Translation(v) ∘ LinearMap(v)</code> (or any combination of <code>LinearMap</code>, <code>Translation</code> and <code>AffineMap</code>).</p><p><code>AffineMap</code>s can be constructed to fit point pairs <code>from_points =&gt; to_points</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; from_points = [[0, 0], [1, 0], [0, 1]];

julia&gt; to_points   = [[1, 1], [3, 1], [1.5, 3]];

julia&gt; AffineMap(from_points =&gt; to_points)
AffineMap([2.0 0.5; 0.0 2.0], [1.0, 1.0])</code></pre><p>(You may get slightly different numerical values due to roundoff errors.) The points can be supplied as a collection of vectors or as a matrix with points as columns.</p><p>If you want to restrict the transformation to be rigid (rotation + translation) or similar (rotation, translation, and scaling), use <code>kabsch</code> instead:</p><pre><code class="language-julia-repl hljs">julia&gt; rigid = kabsch(from_points =&gt; to_points)
AffineMap([0.9912279006826346 0.132163720091018; -0.1321637200910178 0.9912279006826348], [1.4588694597421157, 1.380311939802794])</code></pre><h3 id="Perspective-transformations"><a class="docs-heading-anchor" href="#Perspective-transformations">Perspective transformations</a><a id="Perspective-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Perspective-transformations" title="Permalink"></a></h3><p>The perspective transformation maps real-space coordinates to those on a virtual &quot;screen&quot; of one lesser dimension. For instance, this process is used to render 3D scenes to 2D images in computer generated graphics and games. It is an ideal model of how a pinhole camera operates and is a good approximation of the modern photography process.</p><p>The <code>PerspectiveMap()</code> command creates a <code>Transformation</code> to perform the projective mapping. It can be applied individually, but is particularly powerful when composed with an <code>AffineMap</code> containing the position and orientation of the camera in your scene. For example, to transfer <code>points</code> in 3D space to 2D <code>screen_points</code> giving their projected locations on a virtual camera image, you might use the following code:</p><pre><code class="language-julia hljs">cam_transform = PerspectiveMap() ∘ inv(AffineMap(cam_rotation, cam_position))
screen_points = map(cam_transform, points)</code></pre><p>There is also a <code>cameramap()</code> convenience function that can create a composed transformation that includes the intrinsic scaling (e.g. focal length and pixel size) and offset (defining which pixel is labeled <code>(0,0)</code>) of an imaging system.</p><h2 id="Acknowledgements"><a class="docs-heading-anchor" href="#Acknowledgements">Acknowledgements</a><a id="Acknowledgements-1"></a><a class="docs-heading-anchor-permalink" href="#Acknowledgements" title="Permalink"></a></h2><ul><li>The <a href="https://github.com/FugroRoames">Fugro Roames organization</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Tuesday 4 February 2025 09:53">Tuesday 4 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
