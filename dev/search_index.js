var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API","title":"API Reference","text":"","category":"section"},{"location":"api/#Transformations","page":"API","title":"Transformations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Transformation\nCoordinateTransformations.ComposedTransformation\nIdentityTransformation\nPerspectiveMap\ninv\ncameramap\ncompose\nrecenter\ntransform_deriv\ntransform_deriv_params","category":"page"},{"location":"api/#CoordinateTransformations.Transformation","page":"API","title":"CoordinateTransformations.Transformation","text":"abstract type Transformation\n\nThe Transformation supertype defines a simple interface for performing transformations. Subtypes should be able to apply a coordinate system transformation on the correct data types by overloading the call method, and usually would have the corresponding inverse transformation defined by Base.inv(). Efficient compositions can optionally be defined by compose() (equivalently ∘).\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.ComposedTransformation","page":"API","title":"CoordinateTransformations.ComposedTransformation","text":"ComposedTransformation{T1, T2} <: Transformation\n\nA ComposedTransformation simply executes two transformations T2 and T1 successively, and is the fallback output type of compose().\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.IdentityTransformation","page":"API","title":"CoordinateTransformations.IdentityTransformation","text":"IdentityTransformation <: Transformation\n\nThe IdentityTransformation is a singleton Transformation that returns the input unchanged, similar to identity.\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.PerspectiveMap","page":"API","title":"CoordinateTransformations.PerspectiveMap","text":"PerspectiveMap()\n\nConstruct a perspective transformation. The perspective transformation takes, e.g., a point in 3D space and \"projects\" it onto a 2D virtual screen of an ideal pinhole camera (at distance 1 away from the camera). The camera is oriented towards the positive-Z axis (or in general, along the final dimension) and the sign of the x and y components is preserved for objects in front of the camera (objects behind the camera are also projected and therefore inverted - it is up to the user to cull these as necessary).\n\nThis transformation is designed to be used in composition with other coordinate transformations, defining e.g. the position and orientation of the camera. For example:\n\ncam_transform = PerspectiveMap() ∘ inv(AffineMap(cam_rotation, cam_position))\nscreen_points = map(cam_transform, points)\n\n(see also cameramap)\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.inv","page":"API","title":"Base.inv","text":"inv(trans::Transformation)\n\nReturns the inverse (or reverse) of the transformation trans\n\n\n\n\n\n","category":"function"},{"location":"api/#CoordinateTransformations.cameramap","page":"API","title":"CoordinateTransformations.cameramap","text":"cameramap()\ncameramap(scale)\ncameramap(scale, offset)\n\nCreate a transformation that takes points in real space (e.g. 3D) and projects them through a perspective transformation onto the focal plane of an ideal (pinhole) camera with the given properties.\n\nThe scale sets the scale of the screen. For a standard digital camera, this would be scale = focal_length / pixel_size. Non-square pixels are supported by providing a pair of scales in a tuple, scale = (scale_x, scale_y). Positive scales represent a camera looking in the +z axis with a virtual screen in front of the camera (the x,y coordinates are not inverted compared to 3D space). Note that points behind the camera (with negative z component) will be projected (and inverted) onto the image coordinates and it is up to the user to cull such points as necessary.\n\nThe offset = (offset_x, offset_y) is used to define the origin in the imaging plane. For instance, you may wish to have the point (0,0) represent the top-left corner of your imaging sensor. This measurement is in the units after applying scale (e.g. pixels).\n\n(see also PerspectiveMap)\n\n\n\n\n\n","category":"function"},{"location":"api/#CoordinateTransformations.compose","page":"API","title":"CoordinateTransformations.compose","text":"compose(trans1, trans2)\ntrans1 ∘ trans2\n\nTake two transformations and create a new transformation that is equivalent to successively applying trans2 to the coordinate, and then trans1. By default will create a ComposedTransformation, however this method can be overloaded for efficiency (e.g. two affine transformations naturally compose to a single affine transformation).\n\n\n\n\n\n","category":"function"},{"location":"api/#CoordinateTransformations.recenter","page":"API","title":"CoordinateTransformations.recenter","text":"recenter(trans::Union{AbstractMatrix,Transformation}, origin::Union{AbstractVector, Tuple}) -> ctrans\n\nReturn a new transformation ctrans such that point origin serves as the origin-of-coordinates for trans. Translation by ±origin occurs both before and after applying trans, so that if trans is linear we have\n\nctrans(origin) == origin\n\nAs a consequence, recenter only makes sense if the output space of trans is isomorphic with the input space.\n\nFor example, if trans is a rotation matrix, then ctrans rotates space around origin.\n\n\n\n\n\n","category":"function"},{"location":"api/#CoordinateTransformations.transform_deriv","page":"API","title":"CoordinateTransformations.transform_deriv","text":"transform_deriv(trans::Transformation, x)\n\nA matrix describing how differentials on the parameters of x flow through to the output of transformation trans.\n\n\n\n\n\n","category":"function"},{"location":"api/#CoordinateTransformations.transform_deriv_params","page":"API","title":"CoordinateTransformations.transform_deriv_params","text":"transform_deriv_params(trans::Transformation, x)\n\nA matrix describing how differentials on the parameters of trans flow through to the output of transformation trans given input x.\n\n\n\n\n\n","category":"function"},{"location":"api/#Affine-maps","page":"API","title":"Affine maps","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractAffineMap\nAffineMap\nAffineMap(::Transformation, ::Any)\nAffineMap(::Pair)\nLinearMap\nTranslation\nkabsch","category":"page"},{"location":"api/#CoordinateTransformations.AbstractAffineMap","page":"API","title":"CoordinateTransformations.AbstractAffineMap","text":"abstract type AbstractAffineMap <: Transformation\n\nAbstractAffineMap is the supertype of all affine transformations, including linear transformations.\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.AffineMap","page":"API","title":"CoordinateTransformations.AffineMap","text":"AffineMap <: AbstractAffineMap\n\nA concrete affine transformation.  To construct the mapping x -> M*x + v, use\n\nAffineMap(M, v)\n\nwhere M is a matrix and v a vector.  An arbitrary Transformation may be converted into an affine approximation by linearizing about a point x using\n\nAffineMap(trans, [x])\n\nFor transformations which are already affine, x may be omitted.\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.AffineMap-Tuple{Transformation, Any}","page":"API","title":"CoordinateTransformations.AffineMap","text":"AffineMap(trans::Transformation, x0)\n\nCreate an affine transformation corresponding to the differential transformation of x0 + dx according to trans, i.e. the Affine transformation that is locally most accurate in the vicinity of x0.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoordinateTransformations.AffineMap-Tuple{Pair}","page":"API","title":"CoordinateTransformations.AffineMap","text":"AffineMap(from_points => to_points) → trans\n\nCreate an Affine transformation that approximately maps the from points to the to points. At least n+1 non-degenerate points are required to map an n-dimensional space. If there are more points than this, the transformation will be over-determined and a least-squares solution will be computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoordinateTransformations.LinearMap","page":"API","title":"CoordinateTransformations.LinearMap","text":"LinearMap <: AbstractAffineMap\nLinearMap(M)\n\nA general linear transformation, constructed using LinearMap(M) for any matrix-like object M.\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.Translation","page":"API","title":"CoordinateTransformations.Translation","text":"Translation(v) <: AbstractAffineMap\nTranslation(dx, dy)         # 2D\nTranslation(dx, dy, dz)     # 3D\n\nConstruct the Translation transformation for translating Cartesian points by an offset v = (dx, dy, ...)\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.kabsch","page":"API","title":"CoordinateTransformations.kabsch","text":"kabsch(from_points => to_points, w=ones(npoints); scale::Bool=false, svd=LinearAlgebra.svd) → trans\n\nCompute the rigid transformation (or similarity transformation, if scale=true) that aligns from_points to to_points in a least-squares sense.\n\nOptionally specify the non-negative weights w for each point. The default value of the weight is 1 for each point.\n\nFor differentiability, use svd = GenericLinearAlgebra.svd or other differentiable singular value decomposition.\n\n\n\n\n\n","category":"function"},{"location":"api/#2D-Coordinates","page":"API","title":"2D Coordinates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Polar\nPolarFromCartesian\nCartesianFromPolar","category":"page"},{"location":"api/#CoordinateTransformations.Polar","page":"API","title":"CoordinateTransformations.Polar","text":"Polar{T,A}(r::T, θ::A)\n\n2D polar coordinates\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.PolarFromCartesian","page":"API","title":"CoordinateTransformations.PolarFromCartesian","text":"PolarFromCartesian()\n\nTransformation from AbstractVector of length 2 to Polar type\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.CartesianFromPolar","page":"API","title":"CoordinateTransformations.CartesianFromPolar","text":"CartesianFromPolar()\n\nTransformation from Polar type to SVector{2} type\n\n\n\n\n\n","category":"type"},{"location":"api/#3D-Coordinates","page":"API","title":"3D Coordinates","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Cylindrical\nSpherical","category":"page"},{"location":"api/#CoordinateTransformations.Cylindrical","page":"API","title":"CoordinateTransformations.Cylindrical","text":"Cylindrical(r, θ, z)\n\n3D cylindrical coordinates\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.Spherical","page":"API","title":"CoordinateTransformations.Spherical","text":"Spherical(r, θ, ϕ)\n\n3D spherical coordinates\n\nThere are many Spherical coordinate conventions and this library uses a somewhat exotic one. Given a vector v with Cartesian coordinates xyz, let v_xy = [x,y,0] be the orthogonal projection of v on the xy plane.\n\nr is the radius. It is given by norm(v, 2).\nθ is the azimuth. It is the angle from the x-axis to v_xy\nϕ is the latitude. It is the angle from v_xy to v.\n\njulia> v = randn(3);\n\njulia> sph = SphericalFromCartesian()(v);\n\njulia> r = sph.r; θ = sph.θ; ϕ = sph.ϕ;\n\njulia> v ≈ [r * cos(θ) * cos(ϕ), r * sin(θ) * cos(ϕ), r * sin(ϕ)]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"CartesianFromCylindrical\nCartesianFromSpherical\nCylindricalFromCartesian\nCylindricalFromSpherical\nSphericalFromCartesian\nSphericalFromCylindrical","category":"page"},{"location":"api/#CoordinateTransformations.CartesianFromCylindrical","page":"API","title":"CoordinateTransformations.CartesianFromCylindrical","text":"CartesianFromCylindrical()\n\nTransformation from Cylindrical type to SVector{3} type\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.CartesianFromSpherical","page":"API","title":"CoordinateTransformations.CartesianFromSpherical","text":"CartesianFromSpherical()\n\nTransformation from Spherical type to SVector{3} type\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.CylindricalFromCartesian","page":"API","title":"CoordinateTransformations.CylindricalFromCartesian","text":"CylindricalFromCartesian()\n\nTransformation from 3D point to Cylindrical type\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.CylindricalFromSpherical","page":"API","title":"CoordinateTransformations.CylindricalFromSpherical","text":"CylindricalFromSpherical()\n\nTransformation from Spherical type to Cylindrical type\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.SphericalFromCartesian","page":"API","title":"CoordinateTransformations.SphericalFromCartesian","text":"SphericalFromCartesian()\n\nTransformation from 3D point to Spherical type\n\n\n\n\n\n","category":"type"},{"location":"api/#CoordinateTransformations.SphericalFromCylindrical","page":"API","title":"CoordinateTransformations.SphericalFromCylindrical","text":"SphericalFromCylindrical()\n\nTransformation from Cylindrical type to Spherical type\n\n\n\n\n\n","category":"type"},{"location":"","page":"Introduction","title":"Introduction","text":"DocTestSetup = quote\n    using CoordinateTransformations\nend","category":"page"},{"location":"#CoordinateTransformations","page":"Introduction","title":"CoordinateTransformations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Build Status)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CoordinateTransformations is a Julia package to manage simple or complex networks of coordinate system transformations. Transformations can be easily applied, inverted, composed, and differentiated (both with respect to the input coordinates and with respect to transformation parameters such as rotation angle). Transformations are designed to be light-weight and efficient enough for, e.g., real-time graphical applications, while support for both explicit and automatic differentiation makes it easy to perform optimization and therefore ideal for computer vision applications such as SLAM (simultaneous localization and mapping).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package provide two main pieces of functionality","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Primarily, an interface for defining Transformations and applying (by calling), inverting (inv()), composing (∘ or compose()) and differentiating (transform_deriv() and transform_deriv_params()) them.\nA small set of built-in, composable, primitive transformations for transforming 2D and 3D points (optionally leveraging the StaticArrays and Rotations packages).","category":"page"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Let's translate a 3D point:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using CoordinateTransformations, Rotations, StaticArrays\n\nx = SVector(1.0, 2.0, 3.0)  # SVector is provided by StaticArrays.jl\ntrans = Translation(3.5, 1.5, 0.0)\n\ny = trans(x)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can either apply different transformations in turn,","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"rot = LinearMap(RotX(0.3))  # Rotate 0.3 radians about X-axis, from Rotations.jl\n\nz = trans(rot(x))","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or build a composed transformation using the ∘ operator (accessible at the REPL by typing \\circ then tab):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"composed = trans ∘ rot  # alternatively, use compose(trans, rot)\n\ncomposed(x) == z","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A composition of a Translation and a LinearMap results in an AffineMap.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can invert the transformation:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"composed_inv = inv(composed)\n\ncomposed_inv(z) == x","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For any transformation, we can shift the origin to a new point using recenter:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"rot_around_x = recenter(rot, x)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now rot_around_x is a rotation around the point x = SVector(1.0, 2.0, 3.0).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, we can construct a matrix describing how the components of z differentiates with respect to components of x:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# In general, the transform may be non-linear, and thus we require\n# the value of x to compute the derivative\n∂z_∂x = transform_deriv(composed, x)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Or perhaps we want to know how y will change with respect to changes of to the translation parameters:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"∂y_∂θ = transform_deriv_params(trans, x)","category":"page"},{"location":"#Interface","page":"Introduction","title":"Interface","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Transformations are derived from Transformation. As an example, we have Translation{T} <: Transformation. A Translation will accept and translate points in a variety of formats, such as Vector or SVector, but in general your custom-defined Transformations could transform any Julia object.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Transformations can be reversed using inv(trans). They can be chained together using the ∘ operator (trans1 ∘ trans2) or compose function (compose(trans1, trans2)). In this case, trans2 is applied first to the data, before trans1. Composition may be intelligent, for instance by precomputing a new Translation by summing the elements of two existing Translations, and yet other transformations may compose to the IdentityTransformation. But by default, composition will result in a ComposedTransformation object which simply dispatches to apply the transformations in the correct order.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Finally, the matrix describing how differentials propagate through a transform can be calculated with the transform_deriv(trans, x) method. The derivatives of how the output depends on the transformation parameters is accessed via transform_deriv_params(trans, x). Users currently have to overload these methods, as no fall-back automatic differentiation is currently included. Alternatively, all the built-in types and transformations are compatible with automatic differentiation techniques, and can be parameterized by DualNumbers' DualNumber or ForwardDiff's Dual.","category":"page"},{"location":"#Built-in-transformations","page":"Introduction","title":"Built-in transformations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A small number of 2D and 3D coordinate systems and transformations are included. We also have IdentityTransformation and ComposedTransformation, which allows us to nest together arbitrary transformations to create a complex yet efficient transformation chain.","category":"page"},{"location":"#Coordinate-types","page":"Introduction","title":"Coordinate types","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package accepts any AbstractVector type for Cartesian coordinates. For speed, we recommend using a statically-sized container such as SVector{N} from StaticArrays.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We do provide a few specialist coordinate types. The Polar(r, θ) type is a 2D polar representation of a point, and similarly in 3D we have defined Spherical(r, θ, ϕ) and Cylindrical(r, θ, z).","category":"page"},{"location":"#Coordinate-system-transformations","page":"Introduction","title":"Coordinate system transformations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Two-dimensional coordinates may be converted using these parameterless (singleton) transformations:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PolarFromCartesian()\nCartesianFromPolar()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Three-dimensional coordinates may be converted using these parameterless transformations:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"SphericalFromCartesian()\nCartesianFromSpherical()\nSphericalFromCylindrical()\nCylindricalFromSpherical()\nCartesianFromCylindrical()\nCylindricalFromCartesian()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"However, you may find it simpler to use the convenience constructors like Polar(SVector(1.0, 2.0)).","category":"page"},{"location":"#Translations","page":"Introduction","title":"Translations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Translations can be be applied to Cartesian coordinates in arbitrary dimensions, by e.g. Translation(Δx, Δy) or Translation(Δx, Δy, Δz) in 2D/3D, or by Translation(Δv) in general (with Δv an AbstractVector). Compositions of two Translations will intelligently create a new Translation by adding the translation vectors.","category":"page"},{"location":"#Linear-transformations","page":"Introduction","title":"Linear transformations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Linear transformations (a.k.a. linear maps), including rotations, can be encapsulated in the LinearMap type, which is a simple wrapper of an AbstractMatrix.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You are able to provide any matrix of your choosing, but your choice of type will have a large effect on speed. For instance, if you know the dimensionality of your points (e.g. 2D or 3D) you might consider a statically sized matrix like SMatrix from StaticArrays.jl. We recommend performing 3D rotations using those from Rotations.jl for their speed and flexibility. Scaling will be efficient with Julia's built-in UniformScaling. Also note that compositions of two LinearMaps will intelligently create a new LinearMap by multiplying the transformation matrices.","category":"page"},{"location":"#Affine-maps","page":"Introduction","title":"Affine maps","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An Affine map encapsulates a more general set of transformation which are defined by a composition of a translation and a linear transformation. An AffineMap is constructed from an AbstractVector translation v and an AbstractMatrix linear transformation M. It will perform the mapping x -> M*x + v, but the order of addition and multiplication will be more obvious (and controllable) if you construct it from a composition of a linear map and a translation, e.g. Translation(v) ∘ LinearMap(v) (or any combination of LinearMap, Translation and AffineMap).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"AffineMaps can be constructed to fit point pairs from_points => to_points:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> from_points = [[0, 0], [1, 0], [0, 1]];\n\njulia> to_points   = [[1, 1], [3, 1], [1.5, 3]];\n\njulia> AffineMap(from_points => to_points)\nAffineMap([2.0 0.5; 0.0 2.0], [1.0, 1.0])","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(You may get slightly different numerical values due to roundoff errors.) The points can be supplied as a collection of vectors or as a matrix with points as columns.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you want to restrict the transformation to be rigid (rotation + translation) or similar (rotation, translation, and scaling), use kabsch instead:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> rigid = kabsch(from_points => to_points)\nAffineMap([0.9912279006826346 0.132163720091018; -0.1321637200910178 0.9912279006826348], [1.4588694597421157, 1.380311939802794])","category":"page"},{"location":"#Perspective-transformations","page":"Introduction","title":"Perspective transformations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The perspective transformation maps real-space coordinates to those on a virtual \"screen\" of one lesser dimension. For instance, this process is used to render 3D scenes to 2D images in computer generated graphics and games. It is an ideal model of how a pinhole camera operates and is a good approximation of the modern photography process.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The PerspectiveMap() command creates a Transformation to perform the projective mapping. It can be applied individually, but is particularly powerful when composed with an AffineMap containing the position and orientation of the camera in your scene. For example, to transfer points in 3D space to 2D screen_points giving their projected locations on a virtual camera image, you might use the following code:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"cam_transform = PerspectiveMap() ∘ inv(AffineMap(cam_rotation, cam_position))\nscreen_points = map(cam_transform, points)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There is also a cameramap() convenience function that can create a composed transformation that includes the intrinsic scaling (e.g. focal length and pixel size) and offset (defining which pixel is labeled (0,0)) of an imaging system.","category":"page"},{"location":"#Acknowledgements","page":"Introduction","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The Fugro Roames organization","category":"page"}]
}
